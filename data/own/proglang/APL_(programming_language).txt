APL (programming language) - Wikipedia, the free encyclopedia 
 
 
 
 
 
 
 
 
 
 
 
 
 
 





 
 
		 
		 
		 
			 
			 
						 
						 APL (programming language) 
			 
								 From Wikipedia, the free encyclopedia 
								 
												 
					Jump to:					 navigation , 					 search 
				 
				 "APL programming language family" redirects here. For programming languages that were influenced by APL, see Category:APL programming language family . 
 
 APL 
 
 Paradigm(s) 
 array , functional , structured , modular 
 
 
 Appeared in 
 1964 
 
 
 Designed by 
 Kenneth E. Iverson 
 
 
 Developer 
 Kenneth E. Iverson 
 
 
 Typing discipline 
 dynamic 
 
 
 Major implementations 
 Dyalog APL , IBM APL2 , APL2000 , Sharp APL, APLX , NARS2000 , GNU APL  
 
 
 Dialects 
 A+ , Dyalog APL, APLNext, ELI , J 
 
 
 Influenced by 
 mathematical notation 
 
 
 Influenced 
 J ,   PPL , Q 
 
 
 
 
 
 This article contains APL source code . Without proper rendering support , you may see question marks, boxes, or other symbols instead of APL symbols . 
 
 
 
 
 
  
Promotional material for APL from 1976 
 
 
 APL (named after the book A Programming Language )  
 
 
 
 Contents 
 
 
 1 History 
 
 1.1 APL2 
 1.2 Microcomputers 
 1.3 Extensions 
 
 
 2 Design 
 3 Execution 
 
 3.1 Interpreters 
 3.2 Compilers 
 3.3 Matrix optimizations 
 
 
 4 Terminology 
 5 Syntax 
 6 Examples 
 7 Character set 
 8 Use 
 9 Standardization 
 10 See also 
 11 References 
 12 Further reading 
 13 External links 
 
 
 
 History  
 The first incarnation of what was later to be the APL programming language was published and formalized in A Programming Language ,  a book describing a notation invented in 1957 by Kenneth E. Iverson while at Harvard University . Iverson had developed a mathematical notation for manipulating arrays that he taught to his students. 
 Iverson described the premise of the book in the Preface: "Applied mathematics is largely concerned with the design and analysis of explicit procedures for calculating the exact or approximate values of various functions. Such explicit procedures are called algorithms or programs . Because an effective notation for the description of programs exhibits considerable syntactic structure, it is called a programming language ." 
 In 1960, he began work for IBM and, working with Adin Falkoff , created APL based on the notation he had developed. This notation was used inside IBM for short research reports on computer systems, such as the Burroughs B5000 and its stack mechanism when stack machines versus register machines were being evaluated by IBM for upcoming computers. 
 Also in 1960, Iverson was already using his notation in a draft copy of Chapter 6 called "A programming language" for the book he was writing with Fred Brooks , Automatic Data Processing , which would later be published in 1963.  
 Published in 1962, the notation described in A Programming Language  was recognizable yet distinct from later APL. 
 As early as 1962, the first attempt to use the notation to describe a complete computer system happened after Falkoff discussed with Dr. William C. Carter his work in the standardization of the instruction set for the machines that later became the IBM System/360 family. 
 In 1963, Dr. Herbert Hellerman, working at the IBM Systems Research Institute, implemented a part of the notation on an IBM 1620 computer, and it was used by students in a special high school course on calculating transcendental functions by series summation. Students tested their code in Dr. Hellerman's lab. This implementation of a portion of the notation was called PAT (Personalized Array Translator).  
 In 1963, Falkoff, Iverson, and Edward H. Sussenguth Jr. , all working at IBM, used the notation for a formal description of the IBM System/360 series machine architecture and functionality, which resulted in a paper published in IBM Systems Journal in 1964. After this was published, the team turned their attention to an implementation of the notation on a computer system. One of the motivations for this focus of implementation was the interest of John L. Lawrence who had new duties with Science Research Associates , an educational company bought by IBM in 1964. Lawrence asked Iverson and his group to help utilize the language as a tool for the development and use of computers in education.  
 After Lawrence M. Breed and Philip S. Abrams of Stanford University joined the team at IBM Research, they continued their prior work on an implementation programmed in FORTRAN IV for a portion of the notation was done for the IBM 7090 computer running under the IBSYS operating system. This work was finished in late 1965 and later known as IVSYS (Iverson System). The basis of this implementation was described in detail by Abrams in a Stanford University Technical Report, "An Interpreter for Iverson Notation" in 1966.  
 
 
 
  
IBM typeballs (one OCR) with clip, €2 coin for scale 
 
 
 A key development in the ability to use APL effectively, before the widespread use of CRT terminals, was the development of a special IBM Selectric typewriter interchangeable typeball with all the special APL characters on it. This was used on paper printing terminal workstations using the Selectric typewriter and typeball mechanism, such as the IBM 1050 and IBM 2741 terminal. Keycaps could be placed over the normal keys to show which APL characters would be entered and typed when that key was struck. For the first time, a programmer could actually type in and see real APL characters as used in Iverson's notation and not be forced to use awkward English keyword representations of them. Falkoff and Iverson had the special APL Selectric typeballs, 987 and 988, designed in late 1964, although no APL computer system was available to use them.  
 
 
 
 
  
A programmer's view of the IBM 2741 keyboard layout with the APL typeball print head inserted 
 
 
 
 Some APL symbols, even with the APL characters on the typeball, still had to be typed in by over-striking two existing typeball characters. An example would be the "grade up" character, which had to be made from a "delta" (shift-H) and a " Sheffer stroke " (shift-M). This was necessary because the APL character set was larger than the 88 characters allowed on the Selectric typeball. 
 The first APL interactive login and creation of an APL workspace was in 1966 by Larry Breed using an IBM 1050 terminal at the IBM Mohansic Labs near Thomas J. Watson Research Center , the home of APL, in Yorktown Heights, New York .  
 IBM was chiefly responsible for the introduction of APL to the marketplace. APL was first available in 1967 for the IBM 1130 as APL\1130 .  It would run in as little as 8k 16-bit words of memory, and used a dedicated 1 megabyte hard disk. 
 APL gained its foothold on mainframe timesharing systems from the late 1960s through the early 1980s, in part because it would run on lower-specification systems that were not equipped with Dynamic Address Translation hardware.  Additional improvements in performance for selected IBM System/370 mainframe systems included the "APL Assist Microcode" in which some support for APL execution was included in the actual firmware as opposed to APL being exclusively a software product. Somewhat later, as suitably performing hardware was finally becoming available in the mid- to late-1980s, many users migrated their applications to the personal computer environment. 
 Early IBM APL interpreters for IBM 360 and IBM 370 hardware implemented their own multi-user management instead of relying on the host services, thus they were timesharing systems in their own right. First introduced in 1966, the APL\360  
 In 1973, IBM released APL.SV , which was a continuation of the same product, but which offered shared variables as a means to access facilities outside of the APL system, such as operating system files. In the mid-1970s, the IBM mainframe interpreter was even adapted for use on the IBM 5100 desktop computer, which had a small CRT and an APL keyboard, when most other small computers of the time only offered BASIC . In the 1980s, the VSAPL program product enjoyed widespread usage with CMS , TSO , VSPC , MUSIC/SP and CICS users. 
 In 1973-1974, Dr. Patrick E. Hagerty directed the implementation of the University of Maryland APL interpreter for the Sperry Univac 1100 Series mainframe computers.  
 Several timesharing firms sprang up in the 1960s and 1970s that sold APL services using modified versions of the IBM APL\360  interpreter. In North America, the better-known ones were I. P. Sharp Associates , STSC , and The Computer Company (TCC). With the advent first of less expensive mainframes such as the IBM 4300 and later the personal computer, the timesharing industry had all but disappeared by the mid-1980s. 
 Sharp APL was available from I. P. Sharp Associates , first on a timesharing basis in the 1960s, and later as a program product starting around 1979. Sharp APL was an advanced APL implementation with many language extensions, such as packages (the ability to put one or more objects into a single variable), file system, nested arrays, and shared variables . 
 APL interpreters were available from other mainframe and mini-computer manufacturers as well, notably Burroughs , CDC , Data General , DEC , Harris , Hewlett-Packard , Siemens AG , Xerox , and others. 
 Garth Foster of Syracuse University sponsored regular meetings of the APL implementers' community at Syracuse's Minnowbrook Conference Center in rural upstate New York . In later years, Eugene McDonnell organized similar meetings at the Asilomar Conference Grounds near Monterey, California, and at Pajaro Dunes near Watsonville, California. The SIGAPL special interest group of the Association for Computing Machinery continues to support the APL community.  
 In 1979, Iverson received the Turing Award for his work on APL.  
 APL2  
 Starting in the early 1980s, IBM APL development, under the leadership of Dr Jim Brown , implemented a new version of the APL language that contained as its primary enhancement the concept of nested arrays , where an array can contain other arrays, as well as new language features which facilitated the integration of nested arrays into program workflow. Ken Iverson, no longer in control of the development of the APL language, left IBM and joined I. P. Sharp Associates , where one of his major contributions was directing the evolution of Sharp APL to be more in accordance with his vision.  
 As other vendors were busy developing APL interpreters for new hardware, notably Unix -based microcomputers , APL2 was almost always the standard chosen for new APL interpreter developments. Even today, most APL vendors cite APL2 compatibility, which only approaches 100%, as a selling point for their products.  
 APL2 for IBM mainframe computers is still available as of 2013-07-29,  
 Microcomputers  
 The first microcomputer implementation of APL was on the Intel 8008 -based MCM/70 , the first general purpose personal computer, in 1973. 
 IBM's own IBM 5100 microcomputer (1975) offered APL as one of two built-in ROM-based interpreted languages for the computer, complete with a keyboard and display that supported all the special symbols used in the language. 
 In 1976 DNA Systems introduced an APL interpreter for their TSO Operating System, which ran timesharing on the IBM 1130, Digital Scientific Meta-4, General Automation GA 18/30 and Computer Hardware CHI 21/30. 
 The VideoBrain Family Computer , released in 1977, only had one programming language available for it, and that was a dialect of APL called APL/S.  
 A Small APL for the Intel 8080 called EMPL was released in 1977, and Softronics APL, with most of the functions of full APL, for 8080-based CP/M systems was released in 1979. 
 In 1977, the Canadian firm Telecompute Integrated Systems, Inc. released a business-oriented APL interpreter known as TIS APL, for Z80-based systems. It featured the full set of file functions for APL, plus a full screen input and switching of right and left arguments for most dyadic operators by introducing the ~. prefix to all single character dyadic functions such as - or / . 
 Vanguard APL was available for Z80 CP/M -based processors in the late 1970s. TCC released APL.68000 in the early 1980s for Motorola 68000 -based processors, this system being the basis for MicroAPL Limited's APLX product. I. P. Sharp Associates released a version of their APL interpreter for the IBM PC and PC/370 .  
 The Commodore SuperPET , introduced in 1981, included an APL interpreter developed by the University of Waterloo . 
 In the early 1980s, the Analogic Corporation developed The APL Machine , which was an array processing computer designed to be programmed only in APL. There were actually three processing units, the user's workstation, an IBM PC , where programs were entered and edited, a Motorola 68000 processor that ran the APL interpreter, and the Analogic array processor that executed the primitives.  At the time of its introduction, The APL Machine was likely the fastest APL system available. Although a technological success, The APL Machine was a marketing failure. The initial version supported a single process at a time. At the time the project was discontinued, the design had been completed to allow multiple users. As an aside, an unusual aspect of The APL Machine was that the library of workspaces was organized such that a single function or variable that was shared by many workspaces existed only once in the library. Several of the members of The APL Machine project had previously spent a number of years with Burroughs implementing APL\700 . 
 At one stage, it was claimed by Bill Gates in his Open Letter to Hobbyists , Microsoft Corporation planned to release a version of APL, but these plans never materialized. 
 An early 1978 publication of Rodnay Zaks from Sybex was A microprogrammed APL implementation ISBN 0-89588-005-9 , which is the complete source listing for the microcode for a Digital Scientific Corporation Meta 4 microprogrammable processor implementing APL. This topic was also the subject of his PhD thesis.  
 In 1979, William Yerazunis wrote a partial version of APL in Prime Computer FORTRAN, extended it with graphics primitives, and released it. This was also the subject of his Masters thesis.  
 Extensions  
 Recent extensions to APL include: 
 
 Object-oriented programming  
 Support for .NET ,  operating system resources &amp; connectivity 
 APL as a native .NET language using Visual Studio 2008  
 Integrated charting  and manipulation of SQL databases 
 XML-array conversion primitives  
 Lambda expressions  
 
 Design  
 
 
 
  
 
 This section does not cite any references or sources . Please help improve this section by adding citations to reliable sources . Unsourced material may be challenged and removed . (December 2012) 
 
 
 
 
 
 
 
 This section's tone or style may not reflect the encyclopedic tone used on Wikipedia . See Wikipedia's guide to writing better articles for suggestions. (January 2012) 
 
 
 Unlike traditionally structured programming languages, code in APL is typically structured as chains of monadic or dyadic functions and operators acting on arrays . As APL has many nonstandard primitives (functions and operators, indicated by a single symbol or a combination of a few symbols), it does not have function or operator precedence . Early APL implementations did not have control structures (do or while loops, if-then-else), but by using array operations, use of structured programming constructs was not necessary, as an operation was carried out on all the elements of the array in a single statement. For example, the iota (ι) function (ιN yields a one-dimensional array, or vector, 1 2 3 ... N) can replace for-loop iteration . More recent implementations of APL generally include comprehensive control structures, so that data structure and program control flow can be clearly and cleanly separated. 
 The APL environment is called a workspace . In a workspace the user can define programs and data, i.e. the data values exist also outside the programs, and the user can manipulate the data without the necessity to define a program. For example, 
 
N ← 4 5 6 7
 
 assigns the vector value 4 5 6 7 to N; 
 
N+4
 
 adds 4 to all elements of the vector (giving 8 9 10 11) and prints them (a return value not assigned at the end of a statement to a variable using the assignment arrow is displayed by the APL interpreter); 
 
+/N
 
 prints the sum of N, i.e. 22. 
 These operations can then be combined in a single statement, e.g. 
 
m ← +/ιn
 
 assigns to m the scalar value n(n+1)/2, i.e. . 
 The user can save the workspace with all values, programs and execution status. 
 APL is well known for its use of a set of non- ASCII symbols, which are an extension of traditional arithmetic and algebraic notation. Having single character names for SIMD vector functions is one way that APL enables compact formulation of algorithms for data transformation such as computing Conway's Game of Life in one line of code.  
 Because of the unusual character set , many programmers use special keyboards with APL keytops for authoring APL code. Although there are various ways to write APL code using only ASCII characters,  Most if not all modern implementations use standard keyboard layouts, with special mappings or input method editors to access non-ASCII characters. Historically, the APL font has been distinctive, with uppercase italic alphabetic characters and upright numerals and symbols. Most vendors continue to display the APL character set in a custom font. 
 Advocates of APL  
 Iverson later designed the J programming language , which uses ASCII with digraphs instead of special symbols. 
 Execution  
 
 
 
  
 
 This section does not cite any references or sources . Please help improve this section by adding citations to reliable sources . Unsourced material may be challenged and removed . (December 2012) 
 
 
 Interpreters  
 APLNext (formerly APL2000) offers an advanced APL interpreter that operates under Linux, Unix, and Windows. It supports Windows automation, supports calls to operating system and user defined DLLs, has an advanced APL File System, and represents the current level of APL language development. APL2000's product is an advanced continuation of STSC 's successful APL*Plus/PC and APL*Plus/386 product line. 
 Dyalog APL is an advanced APL interpreter that operates under Linux, Unix, and Windows. Dyalog has innovative extensions to the APL language, which include new object-oriented features, numerous language enhancements, plus a consistent namespace model used for both its Microsoft Automation interface, as well as native namespaces. For the Windows platform, Dyalog APL offers tight integration with .NET, plus limited integration with the Microsoft Visual Studio development platform. 
 IBM offers a version of IBM APL2 for IBM AIX, Linux, Sun Solaris and Windows systems. This product is a continuation of APL2 offered for IBM mainframes. IBM APL2 was arguably the most influential APL system, which provided a solid implementation standard for the next set of extensions to the language, focusing on nested arrays. 
 NARS2000 is an open source APL interpreter written by Bob Smith, a well-known APL developer and implementor from STSC in the 1970s and 1980s. NARS2000 contains advanced features and new datatypes, runs natively under Windows (32- and 64-bit versions), and runs under Linux and Apple Mac OS with Wine . 
 MicroAPL Limited offers APLX , a full-featured 64 bit interpreter for Linux , Microsoft Windows , and Mac OS systems. The core language is closely modelled on IBM's APL2 with various enhancements. APLX includes close integration with .NET, Java, Ruby and R. 
 Soliton Incorporated offers the SAX interpreter (Sharp APL for Unix) for Unix and Linux systems, which is a further development of I. P. Sharp Associates' Sharp APL product. Unlike most other APL interpreters, Kenneth E. Iverson had some influence in the way nested arrays were implemented in Sharp APL and SAX. Nearly all other APL implementations followed the course set by IBM with APL2, thus some important details in Sharp APL differ from other implementations. 
 OpenAPL is an open source implementation of APL published by Branko Bratkovic, based on code by Ken Thompson of Bell Laboratories, together with contributions by others. It is licensed under the GNU General Public License , and runs on Unix systems including Linux on x86, SPARC and other CPUs. 
 GNU APL is a free implementation of ISO Standard 13751 and hence similar to APL2. It runs on GNU/Linux and on Windows using Cygwin . It uses Unicode internally. GNU APL was written by Jürgen Sauermann. 
 Compilers  
 APL programs are normally interpreted and less often compiled . In reality, most APL compilers translated source APL to a lower level language such as C , leaving the machine-specific details to the lower level compiler. Compilation of APL programs was a frequently discussed topic in conferences. Although some of the newer enhancements to the APL language such as nested arrays have rendered the language increasingly difficult to compile, the idea of APL compilation is still under development today. 
 In the past, APL compilation was regarded as a means to achieve execution speed comparable to other mainstream languages, especially on mainframe computers. Several APL compilers achieved some levels of success, though comparatively little of the development effort spent on APL over the years went to perfecting compilation into machine code. 
 As is the case when moving APL programs from one vendor's APL interpreter to another, APL programs invariably will require changes to their content. Depending on the compiler, variable declarations might be needed, certain language features would need to be removed or avoided, or the APL programs would need to be cleaned up in some way. Some features of the language, such as the execute function (an expression evaluator) and the various reflection and introspection functions from APL, such as the ability to return a function's text or to materialize a new function from text, are simply not practical to implement in machine code compilation. 
 A commercial compiler was brought to market by STSC in the mid-1980s as an add-on to IBM's VSAPL Program Product. Unlike more modern APL compilers, this product produced machine code that would execute only in the interpreter environment, it was not possible to eliminate the interpreter component. The compiler could compile many scalar and vector operations to machine code, but it would rely on the APL interpreter's services to perform some more advanced functions, rather than attempt to compile them. However, dramatic speedups did occur, especially for heavily iterative APL code. 
 Around the same time, the book An APL Compiler by Timothy Budd appeared in print. This book detailed the construction of an APL translator, written in C , which performed certain optimizations such as loop fusion specific to the needs of an array language. The source language was APL-like in that a few rules of the APL language were changed or relaxed to permit more efficient compilation. The translator would emit C code which could then be compiled and run well outside of the APL workspace. 
 Today, execution speed is less critical and many popular languages are implemented using virtual machines : instructions that are interpreted at runtime. The Burroughs/Unisys APLB interpreter (1982) was the first to use dynamic incremental compilation to produce code for an APL-specific virtual machine. It recompiled on-the-fly as identifiers changed their functional meanings. In addition to removing parsing and some error checking from the main execution path, such compilation also streamlines the repeated entry and exit of user-defined functional operands. This avoids the stack setup and take-down for function calls made by APL's built-in operators such as Reduce and Each. 
 APEX , a research APL compiler, is available from Snake Island Research Inc . APEX compiles flat APL (a subset of ISO N8485) into SAC , a functional array language with parallel semantics, and currently runs under Linux . APEX-generated code uses loop fusion and array contraction , special-case algorithms not generally available to interpreters (e.g., upgrade of permutation vector ), to achieve a level of performance comparable to that of Fortran . 
 The APLNext VisualAPL system is a departure from a conventional APL system in that VisualAPL is a true .NET language which is fully interoperable with other .NET languages such as VB.NET and C# . VisualAPL is inherently object oriented and Unicode-based. While VisualAPL incorporates most of the features of standard APL implementations, the VisualAPL language extends standard APL to be .NET-compliant. VisualAPL is hosted in the standard Microsoft Visual Studio IDE and as such, invokes compilation in a manner identical to that of other .NET languages. By producing Common Intermediate Language (CIL) code, it utilizes the Microsoft just-in-time compiler (JIT) to support 32-bit or 64-bit hardware. Substantial performance speed-ups over standard APL have been reported,  especially when (optional) strong typing of function arguments is used. 
 An APL to C# translator is available from Causeway Graphical Systems . This product was designed to allow the APL code, translated to equivalent C#, to run completely outside of the APL environment. The Causeway compiler requires a run-time library of array functions. Some speedup, sometimes dramatic, is visible, but happens on account of the optimisations inherent in Microsoft's .NET Framework. 
 Matrix optimizations  
 
 
 
  
 
 This section does not cite any references or sources . Please help improve this section by adding citations to reliable sources . Unsourced material may be challenged and removed . (December 2012) 
 
 
 APL was unique in the speed with which it could perform complicated matrix operations. For example, a very large matrix multiplication would take only a few seconds on a machine that was much less powerful than those today.  There were both technical and economic reasons for this advantage: 
 
 Commercial interpreters delivered highly tuned linear algebra library routines. 
 Very low interpretive overhead was incurred per-array—not per-element. 
 APL response time compared favorably to the runtimes of early optimizing compilers. 
 IBM provided microcode assist for APL on a number of IBM/370 mainframes. 
 
 Phil Abrams' much-cited paper "An APL Machine" illustrated how APL could make effective use of lazy evaluation where calculations would not actually be performed until the results were needed and then only those calculations strictly required. An obvious (and easy to implement) lazy evaluation is the J-vector : when a monadic iota is encountered in the code, it is kept as a representation instead of being expanded in memory; in future operations, a J-vector' s contents are the loop's induction register, not reads from memory. 
 Although such techniques were not widely used by commercial interpreters, they exemplify the language's best survival mechanism: not specifying the order of scalar operations or the exact contents of memory. As standardized, in 1983 by ANSI working group X3J10, APL remains highly data-parallel . This gives language implementers immense freedom to schedule operations as efficiently as possible. As computer innovations such as cache memory , and SIMD execution became commercially available, APL programs are ported with almost no extra effort spent re-optimizing low-level details. 
 Terminology  
 
 
 
  
 
 This section does not cite any references or sources . Please help improve this section by adding citations to reliable sources . Unsourced material may be challenged and removed . (December 2012) 
 
 
 APL makes a clear distinction between functions and operators . Functions take arrays (variables or constants or expressions) as arguments, and return arrays as results. Operators (similar to higher-order functions ) take functions or arrays as arguments, and derive related functions. For example the "sum" function is derived by applying the "reduction" operator to the "addition" function. Applying the same reduction operator to the "maximum" function (which returns the larger of two numbers) derives a function which returns the largest of a group (vector) of numbers. In the J language, Iverson substituted the terms "verb" for "function" and "adverb" or "conjunction" for "operator". 
 APL also identifies those features built into the language, and represented by a symbol, or a fixed combination of symbols, as primitives . Most primitives are either functions or operators. Coding APL is largely a process of writing non-primitive functions and (in some versions of APL) operators. However a few primitives are considered to be neither functions nor operators, most noticeably assignment. 
 Some words used in APL literature have meanings that differ from those in both mathematics and the generality of computer science. 
 
 
 Term 
 Description 
 
 
 function 
 operation or mapping that takes zero, one (right) or two (left &amp; right) array valued arguments and may return an array valued result. A function may be:
 
 Primitive: built-in and represented by a single glyph;  
 Defined: as a named and ordered collection of program statements;  
 Derived: as a combination of an operator with its arguments.  
 
 
 
 
 array 
 data valued object of zero or more orthogonal dimensions in row-major order in which each item is a primitive scalar datum or another array.  
 
 
 niladic 
 not taking or requiring any arguments,  
 
 
 monadic 
 requiring only one argument; on the right for a function, on the left for an operator, unary  
 
 
 dyadic 
 requiring both a left and a right argument, binary  
 
 
 ambivalent or nomadic 
 capable of use in a monadic or dyadic context, permitting its left argument to be elided  
 
 
 operator 
 operation or mapping that takes one (left) or two (left &amp; right) function or array valued arguments (operands) and derives a function. An operator may be:
 
 Primitive: built-in and represented by a single glyph;  
 Defined: as a named and ordered collection of program statements.  
 
 
 
 
 Syntax  
 
 
 
  
 
 This section does not cite any references or sources . Please help improve this section by adding citations to reliable sources . Unsourced material may be challenged and removed . (December 2012) 
 
 
 Main article: APL syntax and symbols 
 Examples  
 
 
 
  
 
 This section does not cite any references or sources . Please help improve this section by adding citations to reliable sources . Unsourced material may be challenged and removed . (December 2012) 
 
 
 This displays "Hello, world": 
 
'Hello, world'
 
 A design theme in APL is to define default actions in some cases that would be syntax errors in their equivalent forms in most other programming languages. APL is economical in its character usage. 
 The 'Hello, world' string constant above displays, because display is the default action on any expression for which no action is specified explicitly (e.g. assignment, function parameter). 
 Another example of this theme: Exponentiation in APL is of the form 2⋆3 raising 2 to the power 3. But if no base is specified, as in ⋆3, then one would have a syntax error in its equivalent form in most other programming languages. APL however assumes the missing base to be the natural logarithm constant e (2.71828....), so interpreting ⋆3 as 2.71828⋆3. 
 This following immediate-mode expression generates a typical set of Pick 6 lottery numbers: six pseudo-random integers ranging from 1 to 40, guaranteed non-repeating , and displays them sorted in ascending order: 
 
x
 
 This combines the following APL functions: 
 
 The first to be executed (APL executes from right to left) is the dyadic function "?" (named "Deal" when dyadic) that returns a vector consisting of a select number (left argument: 6 in this case) of random integers ranging from 1 to a specified maximum (right argument: 40 in this case), which, if said maximum ≥ vector length, is guaranteed to be non-repeating. 
 This vector is then assigned to the variable x, because it is needed later. 
 This vector is then sorted in ascending order by the monadic "⍋" function, which has as its right argument everything to the right of it up to the next unbalanced close-bracket or close-parenthesis. The result of ⍋ is the indices that will put its argument into ascending order. 
 Then the output of ⍋ is applied to the variable x, which we saved earlier, and it puts the items of x into ascending sequence. 
 
 Since there is no function to the left of the left-most x to tell APL what to do with the result, it simply outputs it to the display (on a single line, separated by spaces) without needing any explicit instruction to do that. 
 "?" also has a monadic equivalent called "Roll", which simply returns a single random integer between 1 and its sole operand , inclusive. Thus, a role-playing game program might use the expression "?20" to roll a twenty-sided die. 
 The following expression finds all prime numbers from 1 to R. In both time and space, the calculation complexity is (in Big O notation ). 
 
(~R∊R∘.×R)/R←1↓ιR
 
 Executed from right to left, this means: 
 
 ιR creates a vector containing integers from 1 to R (if R = 6 at the beginning of the program, ιR is 1 2 3 4 5 6 ) 
 Drop first element of this vector ( ↓ function), i.e. 1 . So 1↓ιR is 2 3 4 5 6 
 Set R to the new vector ( ← , assignment primitive), i.e. 2 3 4 5 6 
 The / compress function is dyadic (binary) and the interpreter first evaluates its left argument: 
 Generate outer product of R multiplied by R , i.e. a matrix that is the multiplication table of R by R ( °.× function), i.e. 
 
 
 
 4 
 6 
 8 
 10 
 12 
 
 
 6 
 9 
 12 
 15 
 18 
 
 
 8 
 12 
 16 
 20 
 24 
 
 
 10 
 15 
 20 
 25 
 30 
 
 
 12 
 18 
 24 
 30 
 36 
 
 
 
 Build a vector the same length as R with 1 in each place where the corresponding number in R is in the outer product matrix ( ∈ , set inclusion function), i.e. 0 0 1 0 1 
 Logically negate (not) the values in the vector (change zeros to ones and ones to zeros) ( ∼ , logical not function), i.e. 1 1 0 1 0 
 Select the items in R for which the corresponding element is 1 ( / compress function), i.e. 2 3 5 
 
 (Note, this assumes the APL origin is 1, i.e., indices start with 1. APL can be set to use 0 as the origin, which is convenient for some calculations.) 
 The following expression sorts a word list stored in matrix X according to word length: 
 
X
 
 The following function "life", written in Dyalog APL, takes a boolean matrix and calculates the new generation according to Conway's Game of Life . It demonstrates the power of APL to implement a complex algorithm in very little code, but it is also very hard to follow unless one has an advanced knowledge of APL. 
 
life←{↑1 ⍵∨.∧3 4=+/,¯1 0 1∘.⊖¯1 0 1∘.⌽⊂⍵}
 
 In the following example, also Dyalog, the first line assigns some HTML code to a variable txt and then uses an APL expression to remove all the HTML tags, returning the text only as shown in the last line. 
 
txt←' &lt; html &gt;&lt; body &gt;&lt; p &gt; This is ''emphasized'' text &lt; / p &gt;&lt; / body &gt;&lt; / html &gt; '
⎕←{⍵/⍨~{⍵∨≠\⍵}⍵∊'&lt;&gt;'}txt
 This is emphasized text .
 
 Character set  
 
 
 
  
 
 This section does not cite any references or sources . Please help improve this section by adding citations to reliable sources . Unsourced material may be challenged and removed . (December 2012) 
 
 
 Main article: APL (codepage) 
 APL has always been criticized for its choice of a unique, non-standard character set. Some who learn it become ardent adherents, suggesting that there is some weight behind Iverson's idea that the notation used does make a difference. In the beginning, there were few terminal devices that could reproduce the APL character set—the most popular ones employing the IBM Selectric print mechanism along with a special APL type element. Over time, with the universal use of high-quality graphic display, printing devices and Unicode support, the APL character font problem has largely been eliminated; however, the problem of entering APL characters requires the use of input method editors or special keyboard mappings, which may frustrate beginners accustomed to other programming languages. 
 Use  
 APL has long had a small and fervent user base. It was and still is popular in financial and insurance applications, in simulations, and in mathematical applications. APL has been used in a wide variety of contexts and for many and varied purposes. A newsletter titled "Quote-Quad" dedicated to APL has been published since the 1970s by the SIGAPL section of the Association for Computing Machinery (Quote-Quad is the name of the APL character used for text input and output).  
 Before the advent of full-screen systems and until as late as the mid-1980s, systems were written such that the user entered instructions in his own business specific vocabulary. APL time-sharing vendors delivered applications in this form. On the I. P. Sharp timesharing system, a workspace called 39 MAGIC offered access to financial and airline data plus sophisticated (for the time) graphing and reporting. Another example is the GRAPHPAK workspace supplied with IBM's APL2. 
 Because of its matrix operations, APL was for some time quite popular for computer graphics programming, where graphic transformations could be encoded as matrix multiplications. One of the first commercial computer graphics houses, Digital Effects , based in New York City, produced an APL graphics product known as "Visions", which was used to create television commercials and, reportedly, animation for the 1982 film Tron . Digital Effects' use of APL was informally described at a number of SIGAPL conferences in the late 1980s; examples discussed included the early UK Channel 4 TV logo/ident. What is not clear is the extent to which APL was directly involved in the making of Tron , and at this point in time the reference is more of an urban legend or historic curio than much else.  
 Interest in APL has steadily declined since the mid-1980s. This was partially due to the lack of a smooth migration path from higher performing mainframe implementations to low-cost personal computer alternatives, as APL implementations for computers before the Intel 80386 released in the late 1980s were only suitable for small applications. The growth of end-user computing tools such as Microsoft Excel and Microsoft Access also eroded into potential APL usage. These are appropriate platforms for what may have been mainframe APL applications in the 1970s and 1980s. Some APL users migrated to the J programming language , which offers more advanced features. Lastly, the decline was also due in part to the growth of MATLAB , GNU Octave , and Scilab . These scientific computing array-oriented platforms provide an interactive computing experience similar to APL, but more resemble conventional programming languages such as Fortran, and use standard ASCII. 
 Notwithstanding this decline, APL finds continued use in certain fields, such as accounting research.  
 Standardization  
 APL has been standardized by the ANSI working group X3J10 and ISO / IEC Joint Technical Committee 1 Subcommittee 22 Working Group 3. The Core APL language is specified in ISO 8485:1989, and the Extended APL language is specified in ISO/IEC 13751:2001. 
 See also  
 
 A+ (programming language) 
 APL Shared Variables 
 I. P. Sharp Associates 
 IBM Type-III Library 
 IBM 1130 
 Iverson Award 
 J (programming language) 
 LYaPAS 
 Scientific Time Sharing Corporation 
 Soliton Incorporated 
 
 References  
 
 
 ^  "GNU APL" . directory.fsf.org . Free Software Directory . Retrieved 28 September 2013 . &#160; 
 ^  a   b   "A Bibliography of APL and J" . Jsoftware.com . Retrieved 2010-02-03 . &#160; 
 ^  a   b   "Kx Systems&#160;— An Interview with Arthur Whitney&#160;— Jan 2004" . Kx.com. 2004-01-04 . Retrieved 2010-02-03 . &#160; 
 ^  a   b   "The Growth of MatLab&#160;— Cleve Moler" (PDF) . Retrieved 2010-02-03 . &#160; 
 ^  a   b   "About Q'Nial" . Nial.com . Retrieved 2010-02-03 . &#160; 
 ^  a   b   c  Iverson, Kenneth E. (1962). A Programming Language . Wiley. ISBN &#160; 0-471-43014-5 . &#160; 
 ^  "ACM Award Citation&#160;– John Backus. 1977" . Awards.acm.org. 1924-12-03 . Retrieved 2010-02-03 . &#160; 
 ^  "APLX version 4&#160;– from the viewpoint of an experimental physicist. Vector 23.3" . Vector.org.uk. 2008-05-20. Archived from the original on 25 January 2010 . Retrieved 2010-02-03 . &#160; 
 ^  Bergquist, Gary A. (1999). "The future of APL in the insurance world". ACM SIGAPL APL Quote Quad (New York, N.Y.) 30 (1): 16–21. doi : 10.1145/347194.347203 . ISSN &#160; 0163-6006 . &#160; 
 ^  Iverson, Kenneth E., "Automatic Data Processing: Chapter 6: A programming language" , 1960, DRAFT copy for Brooks and Iverson 1963 book, "Automatic Data Processing". 
 ^  Brooks, Fred ; Iverson, Kenneth, (1963), Automatic Data Processing , John Wiley &amp; Sons Inc. 
 ^  Hellerman, H., "Experimental Personalized Array Translator System", Communications of the ACM , 7, 433 (July, 1964). 
 ^  Falkoff, Adin D.; Iverson, Kenneth E., "The Evolution of APL" , ACM SIGPLAN Notices 13, 1978-08. 
 ^  Abrams, Philip S., An interpreter for "Iverson notation" , Technical Report: CS-TR-66-47, Department of Computer Science, Stanford University, August 1966. 
 ^  Haigh, Thomas, "Biographies: Kenneth E. Iverson", IEEE Annals of the History of Computing , 2005 
 ^  a   b  Breed, Larry, "The First APL Terminal Session" , APL Quote Quad , Association for Computing Machinery, Volume 22, Number 1, September 1991, p.2-4. 
 ^  Adin Falkoff - Computer History Museum. "Iverson credited him for choosing the name APL and the introduction of the IBM golf-ball typewriter with the replacement typehead, which provided the famous character set to represent programs." 
 ^  Larry Breed (August 2006). "How We Got to APL\1130" . Vector (British APL Association) 22 (3). ISSN &#160; 0955-1433 . &#160; 
 ^  APL\1130 Manual , May 1969 
 ^  "Remembering APL" . Quadibloc.com . Retrieved 2013-06-17 . &#160; 
 ^  Falkoff, Adin; Iverson, Kenneth E., "APL\360 Users Guide" , IBM Research, Thomas J. Watson Research Center, Yorktown Heights, NY, August 1968. 
 ^  "APL\360 Terminal System" , IBM Research, Thomas J. Watson Research Center, March 1967. 
 ^  a   b  Pakin, Sandra (1968). APL\360 Reference Manual . Science Research Associates, Inc. ISBN &#160; 0-574-16135-X . &#160; 
 ^  Falkoff, Adin D.; Iverson, Kenneth E., The Design of APL , IBM Journal of Research and Development , Volume 17, Number 4, July 1973. "These environmental defined functions were based on the use of still another class of functions—called "I-beams" because of the shape of the symbol used for them—which provide a more general facility for communication between APL programs and the less abstract parts of the system. The I-beam functions were first introduced by the system programmers to allow them to execute System/360 instructions from within APL programs, and thus use APL as a direct aid in their programming activity. The obvious convenience of functions of this kind, which appeared to be part of the language, led to the introduction of the monadic I-beam function for direct use by anyone. Various arguments to this function yielded information about the environment such as available space and time of day." 
 ^  Minker, Jack (January 2004). "Beginning of Computing and Computer Sciences at the University of Maryland" (PDF). Section 2.3.4: University of Maryland. p.&#160;38. Archived from the original on 10 June 2011 . Retrieved 23 May 2011 . &#160; 
 ^  Stebbens, Alan. "How it all began" . LinkedIn . Retrieved 22 May 2011 . &#160; 
 ^  "SIGAPL Home Page" . Sigapl.org . Retrieved 2013-06-17 . &#160; 
 ^  "Turing Award Citation 1979" . Awards.acm.org . Retrieved 2010-02-03 . &#160; 
 ^  "A programming language for problem solving, visualization and database access" . Retrieved 29 July 2013 . &#160; 
 ^  Falkoff, Adin D. (1991). "The IBM family of APL systems" (PDF). IBM Systems Journal ( IBM ) 30 (4): 416–432. doi : 10.1147/sj.304.0416 . Retrieved 2009-06-13 . &#160; 
 ^  "VideoBrain Family Computer" , Popular Science , November 1978, advertisement. 
 ^  Higgins, Donald S., "PC/370 virtual machine" , ACM SIGSMALL/PC Notes , Volume 11, Issue 3 (August 1985), pp.23 - 28, 1985. 
 ^   , Yahoo! Group APL-L , April, 2003 
 ^  Zaks, Rodnay, "A Microprogrammed APL Implementation,", Ph.D. Thesis, University of California, Berkeley, June 1972. 
 ^  Zaks, Rodnay, "Microprogrammed APL,", Fifth IEEE Computer Conference Proceedings, Sep. 1971 p 193 
 ^  William Yerazunis. "A Partial Implementation of APL with Graphics Primitives for PRIME Computers" . Retrieved 2013-08-14 . &#160; 
 ^  a   b   c   "APLX&#160;: New features in Version 5" . Microapl.co.uk. 2009-04-01. Archived from the original on 6 January 2010 . Retrieved 2010-02-03 . &#160; 
 ^  "APL2000 NetAccess" . Apl2000.com . Retrieved 2010-02-03 . &#160; 
 ^  "Introduction to Visual APL" . Visualapl.com . Retrieved 2010-02-03 . &#160; 
 ^  "Dyalog Built-in Charting" . Dyalog.com. Archived from the original on 3 February 2010 . Retrieved 2010-02-03 . &#160; 
 ^  "XML-to-APL Conversion tool in Dyalog APL and APLX" . Dyalog.com . Retrieved 2010-02-03 . &#160; 
 ^  "Dynamic Functions in Dyalog APL&#160;— John Scholes. 1997" (PDF) . Retrieved 2010-02-03 . &#160; 
 ^  "example" . Catpad.net . Retrieved 2013-06-17 . &#160; 
 ^  Dickey, Lee, A list of APL Transliteration Schemes , 1993 
 ^  Iverson K.E., " Notation as a Tool of Thought ", Communications of the ACM , 23: 444-465 (August 1980). 
 ^  a   b   c   d   e   f   "APL concepts" . Microapl.co.uk . Retrieved 2010-02-03 . &#160; 
 ^  "Nested array theory" . Nial.com . Retrieved 2010-02-03 . &#160; 
 ^  a   b   c  "Programmera i APL", Bohman, Fröberg, Studentlitteratur, ISBN 91-44-13162-3 
 ^  Quote-Quad newsletter  
 ^  "Stanford Accounting PhD requirements" . Gsb.stanford.edu . Retrieved 2014-01-09 . &#160; 
 
 
 Further reading  
 
 An APL Machine (1970 Stanford doctoral dissertation by Philip Abrams) 
 A Personal History Of APL (1982 article by Michael S. Montalbano ) 
 McIntyre, Donald B. (1991). "Language as an intellectual tool: From hieroglyphics to APL" . IBM Systems Journal 30 (4). Archived from the original on May 4, 2006. &#160; 
 Iverson, Kenneth E. (1991). "A Personal view of APL" . IBM Systems Journal 30 (4). Archived from the original on February 27, 2008. &#160; 
 A Programming Language by Kenneth E. Iverson 
 APL in Exposition by Kenneth E. Iverson 
 Brooks, Frederick P.; Kenneth Iverson (1965). Automatic Data Processing, System/360 Edition . ISBN 0-471-10605-4 . 
 Askoolum, Ajay (August 2006). System Building with APL + Win . Wiley. ISBN &#160; 978-0-470-03020-2 . &#160; 
 Falkoff, Adin D.; Iverson, Kenneth E. ; Sussenguth, Edward H. (1964). "A Formal Description of SYSTEM/360" . IBM Systems Journal (New York) 3 (3). Archived from the original on February 27, 2008. &#160; 
 History of Programming Languages , chapter 14  
 Banon, Gerald Jean Francis (1989). Bases da Computacao Grafica . Rio de Janeiro: Campus. p.&#160;141. &#160; 
 LePage, Wilbur R. (1978). Applied A.P.L. Programming . Prentice Hall. &#160; 
 
 External links  
 
 
 
 Wikimedia Commons has media related to APL (programming language) . 
 
 
 
 APL on the Open Directory Project 
 comp.lang.apl newsgroup ( Google Groups archive ) 
 APL Wiki 
 SIGAPL 
 OOPAL: Integrating Array Programming in Object-Oriented Programming 
 An introduction to Object Oriented APL 
 Comparison of Black-Scholes options pricing model in many languages, including APL 
 OpenAPL project page on Source Forge 
 The APL c compiler project (Tim Budd et al.) 
 APL2C , a source of links to APL compilers 
 A Practical Introduction to APL1 &amp; APL2 
 License Agreement , IBM APL\360 source code for non-commercial use 
 



 								 
				Retrieved from " http://en.wikipedia.org/w/index.php?title=APL_(programming_language)&amp;oldid=597073370 "				 
												 Categories : Array programming languages Functional languages Dynamic programming languages APL programming language family .NET programming languages IBM software Command shells Programming languages created in 1964  Hidden categories: All articles with dead external links Articles with dead external links from June 2013 All articles with unsourced statements Articles with unsourced statements from April 2010 Articles with unsourced statements from December 2012 Articles needing additional references from December 2012 All articles needing additional references Wikipedia articles needing style editing from January 2012 All articles needing style editing All articles with specifically marked weasel-worded phrases Articles with specifically marked weasel-worded phrases from October 2012 Articles with unsourced statements from March 2013 Articles with unsourced statements from September 2009 Articles with unsourced statements from June 2010 Articles that may contain original research from December 2012 Wikipedia articles needing clarification from June 2010 Commons category template with no category set Commons category with page title same as on Wikidata Articles with Open Directory Project links  												 
							 
		 
		 
			 Navigation menu 
			 
				 
	 Personal tools 
	 
 Create account Log in 	 
 
				 
					 
	 Namespaces 
	 
					 Article 
					 Talk 
			 
 
 
	 
		 
	 Variants 
	 
		 
					 
	 
 
				 
				 
					 
	 Views 
	 
					 Read 
					 Edit 
					 View history 
			 
 
 
	 Actions 
	 
		 
					 
	 
 
 
	 Search 
	 
					 
					 		 
	 
 
				 
			 
			 
					 
				 
	 Navigation 
	 
		 
			 Main page 
			 Contents 
			 Featured content 
			 Current events 
			 Random article 
			 Donate to Wikipedia 
			 Wikimedia Shop 
		 
	 
 
 
	 Interaction 
	 
		 
			 Help 
			 About Wikipedia 
			 Community portal 
			 Recent changes 
			 Contact page 
		 
	 
 
 
	 Tools 
	 
		 
			 What links here 
			 Related changes 
			 Upload file 
			 Special pages 
			 Permanent link 
			 Page information 
			 Data item 
 Cite this page 		 
	 
 
 
	 Print/export 
	 
		 
			 Create a book 
			 Download as PDF 
			 Printable version 
		 
	 
 
 
	 Languages 
	 
		 
			 Aragonés 
			 Български 
			 Dansk 
			 Deutsch 
			 Eesti 
			 Español 
			 Esperanto 
			 فارسی 
			 Français 
			 Gaeilge 
			 Galego 
			 한국어 
			 Italiano 
			 Magyar 
			 मराठी 
			 Bahasa Melayu 
			 Nederlands 
			 日本語 
			 Polski 
			 Português 
			 Română 
			 Русский 
			 Slovenčina 
			 Српски / srpski 
			 Srpskohrvatski / српскохрватски 
			 Suomi 
			 Svenska 
			 Тоҷикӣ 
			 Українська 
			 中文 
			 
			 Edit links 
		 
	 
 
			 
		 
		 
							 
											 This page was last modified on 25 February 2014 at 14:39. 
											 Text is available under the Creative Commons Attribution-ShareAlike License ;
additional terms may apply. By using this site, you agree to the Terms of Use and Privacy Policy. 
Wikipedia® is a registered trademark of the Wikimedia Foundation, Inc. , a non-profit organization. 
									 
							 
											 Privacy policy 
											 About Wikipedia 
											 Disclaimers 
											 Contact Wikipedia 
											 Developers 
											 Mobile view